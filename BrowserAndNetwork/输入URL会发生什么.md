[参考google官方文档](https://developers.google.com/web/updates/2018/09/inside-browser-part2)

首先要了解浏览器的进程和线程的关系：[参考进程和线程](./ThreadsAndProcesses.md)

浏览器进程具有以下线程：UI线程（用于绘制浏览器的按钮和输入字段）、网络线程（处理网络堆栈以从Internet接收数据）、存储线程（用于控制文件的访问）等等。在地址栏输入内容时，输入由ui线程处理。

输入内容：

1、用户在浏览器地址栏输入内容时，**ui线程**会需要对输入内容进行**解析**，并决定是将输入的内容发送到搜索引擎还是请求的网站。

2、当按下Enter键时：UI线程会发起网络调用以获取网站内容。这个时候，浏览器导航栏显示loading状态（页面还是处于前一个，因为新页面的数据还没有响应）。

3、网络线程，获取到url，先去本地缓存中查找是否有缓存文件，如果有，拦截请求。直接200返回，否则进入网络请求过程。

4、网络请求之前会进行DNS解析，以获取请求域名的服务器ip地址。如果请求协议是https,还需要建立TLS连接

5、网络进程解析响应流程；

    5.1 检查状态码，
        如果是301/302，则需要重定向，从 Location自动中读取地址，重新进行第4步
        （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
    5.2 200响应处理：
        检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
6、查找渲染器进程
    
    Network线程确信浏览器应导航到请求的站点，则Network线程将告知UI线程数据已准备就绪。然后，UI线程找到一个渲染器进程来进行网页渲染。

7、提交导航

    就是将已接收到的数据和和准备好的渲染器进程，将IPC（进程间通信）从浏览器进程发送到渲染进程的过程，它还会传递数据流，因此渲染器进程可以继续接收HTML数据。

    文档加载阶段开始。

    1、地址栏已更新，安全指示符和网站设置UI反映了新页面的网站信息

    2、该选项卡的会话历史记录将被更新，因此后退/前进按钮将逐步浏览刚刚导航到的站点

![test18](./images/test18.png)

在用户输入关键字并键入回车之后，在替换新页面之前，会执行当前页面的beforeunload事件（如果存在的话,存在一定的兼容性）
```
window.addEventListener('beforeunload', (event) => {
    console.log(11111)
    // event.preventDefault();
});
```

在进入加载状态时，页面并没有立即跳转到新的页面，而是停留在原页面上