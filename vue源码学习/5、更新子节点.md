在上一节我们说了。更新子节点的提前。

```
// 如果   oldVnode上的children属性 和 Vnode上的children属性 不相等（新旧子节点的VNode是否相同），则更新子节点updateChildren
if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
```
### 更新策略

  主要针对新增节点、更新节点、移动节点、删除节点进行（通过循环新旧节点来比较的）

  * 创建子节点

      如果在newChildren里面的某个节点在循环结束后依旧在oldChildren中找不到相同的节点，那么说明newChildren中的该节点是一个新增节点。 对于新增节点。我们需要执行创建节点的操作（addVnodes方法）。并将新创建的节点插入到oldChildren中所有未处理的节点之前。（为什么要插入到未处理的节点之前）

  * 更新子节点

      当一个节点同时存在于newChildren和oldChildren中，并且位置相同，这种情况只需要进行更新节点的操作就行（updateChildren方法）。
      如果位置不相同，除了对真实DOM进行更新之外，还需要对这个真实DOM节点进行移动节点的操作

  * 移动节点

      移动节点，顾名思义就是说，当一个节点在同时存在于newChildren和oldChildren中，但位置不同，这个时候需要将这个节点以新的VNode的位置为基准进行移动（nodeOps.insertBefore方法）。（只需要将需要移动的节点移动到所有未处理节点的最前面，就能实现。Node.insertBefore()方法即可）

  * 删除节点

    删除子节点。本质上就是删除那些oldChildren中存在，newChildren中不存在的节点。
    当newChildren中的所有节点都循环一遍之后，也就是循环结束之后，如果oldChildren中还有剩余的没有被处理的节点，那么这些节点就是需要删除的节点（removeVnodes方法）。（源码中的removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)）

那么我们来看下源码中的updateChildren的方法

```
function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    let oldStartIdx = 0 // 旧的开始位置索引
    let newStartIdx = 0 // 新的开始位置索引
    let oldEndIdx = oldCh.length - 1 // 旧的结束位置索引
    let oldStartVnode = oldCh[0] // 旧的第一个Vnode
    let oldEndVnode = oldCh[oldEndIdx] // 旧的最后一个Vnode
    let newEndIdx = newCh.length - 1 // 新的结束位置索引
    let newStartVnode = newCh[0] // 新的第一个Vnode
    let newEndVnode = newCh[newEndIdx] // 新的最后一个Vnode
    let oldKeyToIdx, idxInOld, vnodeToMove, refElm

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    const canMove = !removeOnly

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx]
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        oldStartVnode = oldCh[++oldStartIdx]
        newStartVnode = newCh[++newStartIdx]
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        oldEndVnode = oldCh[--oldEndIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
        oldStartVnode = oldCh[++oldStartIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode = oldCh[--oldEndIdx]
        newStartVnode = newCh[++newStartIdx]
      } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        } else {
          vnodeToMove = oldCh[idxInOld]
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
            oldCh[idxInOld] = undefined
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
          }
        }
        newStartVnode = newCh[++newStartIdx]
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
    }
  }

```
