上一篇，我们说了。路由有三种模式。是根据传入的mode来区分的

这里再来回顾下

```
var VueRouter = function VueRouter (options) {
    var mode = options.mode || 'hash' // 默认hash.
    // 如果设置了mode为history并且浏览不支持。
    // 默认转为hash模式
    this.fallback = mode === 'history' && !supportsHistory
    if (this.fallback) {
      mode = 'hash'
    }
    // 如果不在浏览器环境中，则强制转为abstract模式
    if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode
};
VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;
  
    this.app = app
    var ref = this;
    var mode = ref.mode;
    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this)
        break
      default:
        assert(false, ("invalid mode: " + mode))
    }
  
    this.history.listen(function (route) {
      this$1.app._route = route
    })
};
```

那么本章我们来分析下，不同模式的路由实现方式。

再分析具体之前，我们看下构造函数History，因为在new HTML5History(或者其他路由方式的时候，都是继承自History方法)

```
var History = function History (router, base) {
    this.router = router
    this.base = normalizeBase(base)
    // start with a route object that stands for "nowhere"
    this.current = START
    this.pending = null
};
History.prototype.listen = function listen () {};
History.prototype.transitionTo = function transitionTo () {};
History.prototype.confirmTransition = function confirmTransition () {};
History.prototype.updateRoute = function updateRoute () {};
```
### 再来看hash模式（HashHistory）：本质上是监听浏览器的Hashchange事件

```
function HashHistory (router, base, fallback) {
    var this$1 = this;

    History.call(this, router, base) // 调用父类的方法

    if (fallback && this.checkFallback()) {
        return
    }

    this.transitionTo(getHash())

    // 这就是我们router-model中的列子。hash的模式，本质是监听hashchange事件。
    window.addEventListener('hashchange', function () {
        this$1.onHashChange()
    })
}

if ( History ) HashHistory.__proto__ = History; // HashHistory继承History原型上的方法


HashHistory.prototype.onHashChange = function onHashChange () {
    if (!ensureSlash()) {
        return
    }
    this.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath)
    })
};
```

