### ES6 module
在ES6之前。社区提供一些模块化加载的方案：

服务端模块化(node)：CommonJs
```
CommonJs模块
let {stat,readfile} = require(fs)

// 相当于
let _fs = require(fs)
let stat = _fs.stat
let readfile = _fs.readfile

上序代码的实质是：整体加载fs模块。生成一个对象_fs，然后从这个对象读取相对应的方法。 这种加载方式称之为“运行时加载”。因为只有运行时才能获取到这个对象，导致不能再编译时做“静态优化”
```
浏览器端：AMD（代表require.js）CMD(sea.js)


ES6的模块化编译时加载，使得静态分析成为可能。

ES6的模块自动采用严格模式。不论你有没有再某块头定义'use strict'

```
变量必须声明后再使用
函数的参数不能有同名属性，否则报错
不能使用with语句
不能对只读属性赋值，否则报错
不能删除不可删除的属性，否则报错
不能删除变量delete prop，会报错，只能删除属性delete global[prop]
eval不会在它的外层作用域引入变量
eval和arguments不能被重新赋值
arguments不会自动反映函数参数的变化
不能使用arguments.callee
不能使用arguments.caller
禁止this指向全局对象
不能使用fn.caller和fn.arguments获取函数调用的堆栈
增加了保留字（比如protected、static和interface）
```

    ES6的模块主要有两个命令构成：export 和 import

    ES6环境。(搭建webpack)
#### export命令（用于定于规范模块的对外接口）
```
export的正确使用方法：

1、
export var a = 1
export var b = 2

2、建议使用该方式 
var a = 1
var b = 2
export {a, b}

3、通过as关键字能够重命名（也就可以导出多个）
var a = 1
var b = 2
export {
    a as test1, 
    b as test2,
    a as test3
}

export语句输出的接口，与对应的值是动态绑定的关系，即通过接口，可以实时取到模块内部的值。

export var a = 1
setTimeout(() => {
    a = 2
}, 500)
上述代码可以说明这点。500秒之后变为2

这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新

注意：export可以出现在模块的任意顶层的位置，如果处于块级作用域内，会报错

function foo() {
  export var a = 1 // SyntaxError
}
foo()

```

#### import命令（用于输入其他模块提供的功能.也就是加载模块）
```
使用了export导出接口之后，需要对应的import来加载对应的模块

test.js

function a (){
    console.log(111)
}
var b = {
    test: 1
}

use.js

import {a, b} from 'test' // .js后缀可以省略
a() // 111
console.log(b) // {test: 1} 

也可以：
import {a as a1, b as b1} from 'test' 
a1() // 111
console.log(b1) // {test: 1} 

也可以: (模块的整体加载)
import * as obj from 'test'
obj.a1() // 111
console.log(obj.b1) // {test: 1} 

import具有命令提升的作用，会提升至顶部
```
    import语句会执行所加载的模块，因此可以有下面的写法。

    import 'lodash';

    上述只会执行lodash模块。而不会输入任何值

#### export default

从上述例子来看。我们在import加载模块的时候，需要知道export暴露出来的那些接口（名称：变量名或者函数名）。否则无法加载。

```
使用export default 暴露对应的接口，就不会有上述的顾虑

test.js
export default {
    test: 1,
    testA: function(){
        console.log(111)
    }
}

default.js
import def from 'test'
def.test // 1
def.testA() // 111

从上面我们可以看出。使用export default暴露的接口，在使用import的时候不需要使用{} ,直接将接口赋值给def使用。
```
```
本质上。
export default {
    test: 1,
    testA: function(){
        console.log(111)
    }
}
相当于
var default = {
        test: 1,
        testA: function(){
            console.log(111)
        }
    }
export {
    default
}
正是因为，export default输出的是一个变量。所以它后面不能跟变量声明语句。
var b = 1
export var a= 1 // 正常
export b // 报错
export default b //正常
export default var a =1 // 报错


import def from 'test'
相当于
import {default as def} from 'test'
```
```
所以上述中引入lodash.
也可以使用
import _ from 'lodash'
```

#### 模块化加载的实质

Es6的模块化加载和commonjs的加载完全不一样。

ES6模块化加载是对值的引用

CommonJs模块化加载是对值的拷贝（也就是说，一旦加载了，模块内部的变量就不会影响到已经加载的值）
```
在node环境中运行

test.js

var count = 3

function add () {
    count++
}
module.exports = {
    count,
    add
}

module.js
var a = require('./test')
console.log(a.count);  // 3
a.add();
console.log(a.count); // 3
```

#### 循环加载