### ES6 module
在ES6之前。社区提供一些模块化加载的方案：

服务端模块化(node)：CommonJs
```
CommonJs模块
let {stat,readfile} = require(fs)

// 相当于
let _fs = require(fs)
let stat = _fs.stat
let readfile = _fs.readfile

上序代码的实质是：整体加载fs模块。生成一个对象_fs，然后从这个对象读取相对应的方法。 这种加载方式称之为“运行时加载”。因为只有运行时才能获取到这个对象，导致不能再编译时做“静态优化”
```
浏览器端：AMD（代表require.js）CMD(sea.js)


ES6的模块化编译时加载，使得静态分析成为可能。

ES6的模块自动采用严格模式。不论你有没有再某块头定义'use strict'

```
变量必须声明后再使用
函数的参数不能有同名属性，否则报错
不能使用with语句
不能对只读属性赋值，否则报错
不能删除不可删除的属性，否则报错
不能删除变量delete prop，会报错，只能删除属性delete global[prop]
eval不会在它的外层作用域引入变量
eval和arguments不能被重新赋值
arguments不会自动反映函数参数的变化
不能使用arguments.callee
不能使用arguments.caller
禁止this指向全局对象
不能使用fn.caller和fn.arguments获取函数调用的堆栈
增加了保留字（比如protected、static和interface）
```

    ES6的模块主要有两个命令构成：export 和 import

    ES6环境。(搭建webpack)
#### export命令（用于定于规范模块的对外接口）
```
export的正确使用方法：

1、
export var a = 1
export var b = 2

2、建议使用该方式 
var a = 1
var b = 2
export {a, b}

3、通过as关键字能够重命名（也就可以导出多个）
var a = 1
var b = 2
export {
    a as test1, 
    b as test2,
    a as test3
}

export语句输出的接口，与对应的值是动态绑定的关系，即通过接口，可以实时取到模块内部的值。

export var a = 1
setTimeout(() => {
    a = 2
}, 500)
上述代码可以说明这点。500秒之后变为2

这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新

注意：export可以出现在模块的任意顶层的位置，如果处于块级作用域内，会报错

function foo() {
  export var a = 1 // SyntaxError
}
foo()

```

#### import命令（用于输入其他模块提供的功能.也就是引入）