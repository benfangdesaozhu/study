## **this全面解析**
要清楚理解的知道this的绑定，首先我们要清楚**调用位置**

### **调用位置**

**调用位置**就是函数在代码中被调用的位置（非函数声明的位置）
而调用位置最重要的是分析调用栈（就是为了到达当前执行位置所调用的所有函数）
下面举个例子来看看到底什么是调用位置和调用栈

```
function baz () {
    // 2、当前的调用栈是:baz
    // 因此当前的调用位置是全局作用域
    console.log('baz')

    bar() // 3、bar的调用位置
}

function bar () {
    // 4、当前的调用栈是:baz->bar
    // 因此，当前的调用位置在baz中
    console.log('bar')
    foo()// 5、foo的调用位置
}

function foo () {
    // 6、当前的调用栈是:baz->bar->foo
    // 因此，当前的调用位置在bar中
    console.log('foo')
}
baz() // 1、baz的调用位置
// 序列代码执行顺序。通过执行顺序来分析调用位置和调用栈
```
**注意**：我们是如何从调用栈中分析出真正的调用位置的，因为它决定了this的绑定

### **绑定规则**

我们来看看函数的执行过程中调用位置是如何决定this的绑定对象

首先，我们必须找到调用位置，然后判断需要使用以下四条规则中的哪一条。
1. **默认绑定**：
    - 独立函数调用（可以认为这条规则是无法应用其他规则时的默认规则）
    - 这条规则在严格模式下。函数内的this会绑定到undefined
    - 非严格模式下，this会绑定到全局对象
```
function foo () {
    // "use strict"
    console.log(this.a) 
    // 非严格模式：打印出2
    // 严格模式下因为this是undefined.所以undefined.a会报错‘Uncaught TypeError: Cannot read property 'a' of undefined’
}
var a = 2
foo()

```
2. **隐式绑定**
    - 调用位置是否有上下文对象。或者说是否被某个对象拥有或者包含。（需要注意隐式绑定丢失的情况）
    - 对应的函数的调用方法：方法调用

``` 
function foo1 () {
    console.log(this.a)
}
var obj = {
    a: 2,
    foo: foo1
}
// 这里可以看出foo()方法，是obj的引用。所有这个this指向obj对象。
// 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。
// 对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。
obj.foo() // 2 
var yinshi = obj.foo
yinshi() // undefined(特殊，隐式丢失)
// 参数传参也是隐式赋值（会造成隐式丢失）
// 隐式绑定的函数会丢失绑定对象,而this绑定到全局对象或者undefined上，取决于是否是严格模式
```
3. **显示绑定**
    - 硬绑定。对象内部包含一个指向函数的属性（call,apply,bind） 
    - API调用的‘上下文’，es6新增的数组方法（filter,map，forEach 等等的第二个参数，接受的是this的值）
```

```
4. **new绑定**
    - new绑定
    - 对应的函数的调用方法：构造函数调用
```

```
5. **箭头函数绑定**
    - 是

### **优先级**
**默认绑定 < 隐式绑定 < 显式绑定 < new绑定**