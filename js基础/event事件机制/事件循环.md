### **事件循环（event Loop）**

 JavaScript 是单线程、异步、非阻塞、解释型脚本语言。

 浏览器的渲染进程是提供多个线程的:如

* js引擎线程
* 事件触发线程
* 定时触发器线程
* 异步http请求线程
* GUI渲染线程

[浏览器渲染进程参考这里](https://juejin.im/post/6844903553795014663#heading-6)

#### 浏览器中的Event Loop

##### 1、同步和异步

```
setTimeout(function () {
    console.log('fdafadsfsfasdfas')
}, 0)
for(var i =0; i < 10000; i++) {
    console.log(i)
}
// 打印分别是0、1、2、3、...、9999、fdafadsfsfasdfas
```

上面的setTimeout函数不会立即执行（setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行）

异步方法一般包括：

* 网络请求
* 定时器
* dom事件监听
##### 2、macro-Task 宏任务 micro-Task 微任务

浏览器端事件循环中的异步队列有两种：Macro和Micro,Macro任务可有多个，Micro只能只有一个。

常见的Macro-task: setTimeout, setInterval, script（整体代码），I/O操作，UI渲染等

常见的Micro-task：比如：process.nextTick、new promise()、MutationObserver（html新特性）等
##### 3、Event Loop过程解析:
一个完整的事件循环过程，可以概括以下步骤：
* 一开始执行栈为空时，可以把执行栈理解为**一个存储函数调用的栈结构，遵循先进后出的原则额**。Micro为空，Macro队列中有script

* 全局上下文被推入执行栈时，同步执行代码。在执行过程，会判断当前的执行的时同步任务还是异步任务，在执行过程，会产生新的Macro和Micro任务，它们会被推入各自的任务队列当中，同步代码执行完毕后，script脚本会被移出Macro队列，这个过程本质上是Macro-task的执行和出队的过程。
* 上一步是一个 Macro-task出队的过程，这一步我们处理的是 micro-task。但需要注意的是：当 Macro-task 出队时，任务是**一个一个**执行的；而 micro-task 出队时，任务是**一队一队**执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。

* 执行渲染操作，更新界面

* 检查是否存在 Web worker 任务，如果有，则对其进行处理

* 上述过程循环往复，直到两个队列都清空

总结上面所描述的：

当执行宏执行完毕后，会判断任务队列中是否有微任务队列，如果有微任务队列，会执行微任务队列中所有的微任务。如果没有，执行栈会执行宏任务队列中排在最前面的宏任务，在执行过程中，如果遇到微任务，会将微任务放在微任务队列当中。栈空后，再次读取微任务队列里的任务，依次类推。

 看下面的例子
```
<script>
// 为了方便理解，我以打印出来的字符作为当前的任务名称
setTimeout(function() {
    console.log('timeout1');
})

new Promise(function(resolve) {
    console.log('promise1');
    for(var i = 0; i < 1000; i++) {
        i == 99 && resolve();
    }
    console.log('promise2');
}).then(function() {
    console.log('then1');
})

console.log('global1');
</script>
```
按照上述说的，来分析：

首先：事件循环是从宏任务开始的，也就是这个script标签内的代码.这个时候任务队列中，只有一个script(宏任务)，执行当前任务时，如果遇到其他任务时，会将对应任务放到对应的队列中。所以，上面例子的第一步执行如下图所示。

![初始化](https://upload-images.jianshu.io/upload_images/599584-92fc0827aa39e325.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

第二步：当遇到setTimeout的时候，会创建一个新的宏任务，并将新的宏任务放在当前宏任务的后面，形成队列.

![aaa](https://upload-images.jianshu.io/upload_images/599584-2a99131c2572f898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

第三步：当遇到Promise的时候。Promise构造函数中的第一个参数，是在new的时候执行，因此不会进入任何其他的队列，而是直接在当前任务直接执行了，而后续的.then则会被分发到micro-task的Promise队列中去。

因此，构造函数执行时，里面的参数进入函数调用栈执行。for循环不会进入任何队列，因此代码会依次执行，所以这里的promise1和promise2会依次输出。

![](https://upload-images.jianshu.io/upload_images/599584-774ec33de48c1d41.png)

![](https://upload-images.jianshu.io/upload_images/599584-8b5e93798f6c9d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/599584-521c5da565a35a45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


```
console.log('global1');
```
继续执行之后，打印global1,当前全局任务(script宏任务)执行完毕，并出队

第四步：第一个宏任务执行完毕后，因为任务队列当中有可执行的微任务队列，因为便执行promise队列中的任务then1.
![](https://upload-images.jianshu.io/upload_images/599584-dd7673edbbe5e687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

第五步： 当微任务队列的任务都执行完毕后，第一轮的循环就结束了，这时开始第二轮的循环。第二次循环从宏任务队列中最先开始执行的（当前列子只有一个）。
![](https://upload-images.jianshu.io/upload_images/599584-881e739c134cb6c9.png)

第六步：这个时候，宏任务队列中只有一个settimeout,因此开始第二轮的循环执行
![](https://upload-images.jianshu.io/upload_images/599584-c4ea234b27c5f2f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当settimeout执行完毕后，调用栈中没有任何的宏任务和微任务队列后，便结束了

```
// demo02
console.log('golb1');

setTimeout(function() {
    console.log('timeout1');
    process.nextTick(function() {
        console.log('timeout1_nextTick');
    })
    new Promise(function(resolve) {
        console.log('timeout1_promise');
        resolve();
    }).then(function() {
        console.log('timeout1_then')
    })
})

setImmediate(function() {
    console.log('immediate1');
    process.nextTick(function() {
        console.log('immediate1_nextTick');
    })
    new Promise(function(resolve) {
        console.log('immediate1_promise');
        resolve();
    }).then(function() {
        console.log('immediate1_then')
    })
})

process.nextTick(function() {
    console.log('glob1_nextTick');
})
new Promise(function(resolve) {
    console.log('glob1_promise');
    resolve();
}).then(function() {
    console.log('glob1_then')
})

setTimeout(function() {
    console.log('timeout2');
    process.nextTick(function() {
        console.log('timeout2_nextTick');
    })
    new Promise(function(resolve) {
        console.log('timeout2_promise');
        resolve();
    }).then(function() {
        console.log('timeout2_then')
    })
})

process.nextTick(function() {
    console.log('glob2_nextTick');
})
new Promise(function(resolve) {
    console.log('glob2_promise');
    resolve();
}).then(function() {
    console.log('glob2_then')
})

setImmediate(function() {
    console.log('immediate2');
    process.nextTick(function() {
        console.log('immediate2_nextTick');
    })
    new Promise(function(resolve) {
        console.log('immediate2_promise');
        resolve();
    }).then(function() {
        console.log('immediate2_then')
    })
})
```

node的事件循环和浏览器的事件循环区别

https://github.com/ljianshu/Blog/issues/54C

https://yangbo5207.github.io/wutongluo/ji-chu-jin-jie-xi-lie/shi-er-3001-shi-jian-xun-huan-ji-zhi.html